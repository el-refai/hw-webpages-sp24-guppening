<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <style>
    body {
      background-color: #404040;
      background-color: white;
      padding: 100px;
      width: 1000px;
      margin: auto;
      text-align: left;
      font-weight: 300;
      font-family: 'Open Sans', sans-serif;
      color: #121212;
      cursor: url(images/dwagon.png), default!important;
      cursor: url(images/dwagon.png), pointer!important;
    }
    h1, h2, h3, h4 {
      font-family: 'Source Sans Pro', sans-serif;
    }
    kbd {
      color: #121212;
    }
    blockquote {
      color: #888;
      border: 2px solid #333;
      padding: 10px;
      background-color: #ccc;
    }

    table.custom-tbl {
      border: 1px solid;
    }

    table.custom-tbl th {
      border: 1px solid;
      background-color: rgb(99, 209, 209);
    }

    table.custom-tbl td {
      border: 1px solid;
      background-color: #f1e686a8;
    }

    /* The alert message box */
    .alert {
      padding: 20px;
      background-color: #f44336; /* Red */
      color: white;
      margin-bottom: 15px;
    }

    /* The close button */
    .closebtn {
      margin-left: 15px;
      color: white;
      font-weight: bold;
      float: right;
      font-size: 22px;
      line-height: 20px;
      cursor: pointer;
      transition: 0.3s;
    }

    /* When moving the mouse over the close button */
    .closebtn:hover {
      color: black;
    }
  </style>

  <title>CS 184 Mesh Editor</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <!-- Not using below due to lacking bold fontfaces -->
  <!-- <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro|Source+Sans+Pro:400,700" rel="stylesheet"> -->
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono|Roboto+Slab|Roboto:300,400,500,700" rel="stylesheet" />

  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>  
</head>

<body
  style="padding-top: 50px;">

  <div align="middle">
    <img src="images/triangle_dragon_banner.webp" 
        align="middle" 
        width="1000vw" />
  </div>
  
  <h1 align="left">CS 184: Computer Graphics and Imaging, Spring 2024</h1>
  <h1 align="left">Homework 1: Rasterizer</h1>
  <h2 align="left">James Deloye, Karim El-Refai, cs-184-guppening</h2>

  <hr />
  <br />

  <div>
    <h2 align="left">Overview</h2>
    <p>
      We implemented everything from rasterizing single-color triangles to then antialiasing these triangles through supersampling. 
      We then got to take a little break designing the matrices in homogenous coordinates that describe translation, scaling, and rotation in 2D. 
      After that we worked on barycentric coordinates to interpolate the values of points along various shapes. 
      From there we got to deal with texture maps and rasterizing them in pixel-space with pixel sampling both using near-neighbors and bilinear sampling.
      Leading us to the last required task which was figuting out which mipmap level to sample from and adding in trilinear interpolation across mipmap levels.
      </p>
      <p>
      <br />
      However, this was not everything we did as we worked on all pieces of extra credit including increasing the speed of our rasterization by <b>~80x</b> on average, jittered sampling, 
      more GUI features [James TALK ABOUT THIS] and lastly the implementation of anisotropic filtering according to the Nvidia specification.
      <br />
    </p>
    <p>
      We found this homework to be deeply instructive in demystifying the task of working with graphics. Neither of us had prior graphics experience but were able to 
      tackle all the tasks and achieve really cool results from our work on the extra credit. The most interesting things we dealt with in this project were how to 
      greatly speed up triangle rasterization and working on anisotropic filtering. 
    </p>
  </div>



  <hr />
  <br />
  <h2 align="middle">Task 1: Drawing Single-Color Triangles</h2>

  <h3>Overview</h3>
    <p>
      Our initial attempt at rasterizating the triangle begins by determining if the vertices are given in a clockwise or counter-clockwise order. If they are clockwise then we change them to be counter-clockwise. We then determine the tightest bounding box around the triangle. 
      We then scan across this bounding box and query the pixels to see if they fall within the triangle. This is done by first generating the vectors corresponding to vectors perpendicular to the lines of the triangle, i.e. given vertex A,B,C we calculate Perp(A->B), Perp(B->C), Perp(C->A). Then given a pixel P we find the vector from a given vertex to P, ex: A->P. Then we take the dot product of the two vectors. Since we're evaluating the points counter-clockwise if all of the dot products are greater than or equal to 0, i.e. they lie on the line or are above it we will then add that pixel to the sample buffer.
      <br />
      This naive implementation is no worse than an implementation that checks each sample within the bounding box of the triangle as it is doing exactly that. Note that in the extra credit section below we make <b>substantial</b> improvements to our rasterization algorithm that severely outperforms the bounding box implementation. 
    </p>

    
    <blockquote><b>
      Show a png screenshot of basic/test4.svg with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.
    </b></blockquote>

    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
            <img src="images/task1.png" align="middle" width="700vw" />
            <figcaption>Here is the rasterizer working on basic/test4.svg. An interesting thing, as evidenced by the pixel inspector is how on the rightmost end of the red triangle it thins down to just a single pixel in thickness and actually oscillates between rasterizing any of the triangle and not. </figcaption>
          </td>
        </tr>
      </table>
    </div>


    <blockquote><b>
      Extra credit: Explain any special optimizations you did beyond simple bounding box triangle rasterization.
    </b></blockquote>    
    <p>
      Before doing any optimizing we designed a consistent testing methodology in order to compare between rasterization methods. For each method, we rasterized each of the 4 basic SVGs 10 times at 16x supersampling and took the average of all of them. This was done in order to show the greatest possible differences in the rendering methods. We used the std::chrono::steadyclock to measure the time that it took to render all the triangles for maximum consistency and then found the speedup against the naiive baseline bounding box method. We did the optimizations in stages as follows:
    </p>
    <ol>
      <li>
        We started with just the basic bounding box algorithm implemented in the most naiive way possible. We used this as our baseline that we compared other methods to. 
      </li>
      <li>
        We began by removing unnecessary computations, like repeated square roots for supersampling computations and the subtractions (like y1-y0) that were previously repeated for checking if each pixel was inside the triangle. Though this does result in more memory accesses, assuming good caching there will be less operations in total. These results are in the second column below. 
      </li>
      <li>
        From this point on, we apprached the rendering in a completely different method than was done previously. Instead of trying individual pixels to determine whether they were in the triangle, we started at the minimum y value in the triangle, found the pixels at which the triangle's edges intercepted that y value, then used the std::fill function to fill all the values between the two (sub)pixels. This was done until the entire triangle had been scanned. Technically, this was done in two phases, first where the triangle was widening and then when it was thinning, identifying the appropriate right and left edges using information about the orientation of the vertices. The loops were done with a while loop method, as this was simplest to implement intially. These results are in the third column below.
      </li>
      <li>
        In preparation for a final optimization using multithreading in order to parallelize the triangle filling loops, we switched the while loops to for loops. While it turned out that the overhead of spawning the threads was too high for the relatively small triangles, the for loops did slightly speed up the overall computation, likely due to assembly and branch prediction compiler optimizations. These results are in the fourth column below.
      </li>
    </ol>
    <head>
      <title>Performance Table</title>
      <style>
        table {
          width: 100%;
          border-collapse: collapse;
        }
        table, th, td {
          border: 1px solid black;
        }
        th, td {
          padding: 8px;
          text-align: center;
        }
        th {
          background-color: #f2f2f2;
        }
      </style>
      </head>
      <div align="middle">
      
      <table>
        <tr>
          <th>SVG File</th>
          <th>Slow (naive with bounding box)</th>
          <th>Fast (repetitive computations removed)</th>
          <th>Faster (new algorithm)</th>
          <th>Fastest (for loop)</th>
        </tr>
        <tr>
          <th>Dragon Time</th>
          <td>6464845470</td>
          <td>1461548720</td>
          <td>49709560</td>
          <td>46949350</td>
        </tr>
        <tr>
          <th>Dragon Speedup</th>
          <td>1</td>
          <td>4.423284275</td>
          <td>130.0523575</td>
          <td>137.6982955</td>
        </tr>
        <tr>
          <th>Triangles Time</th>
          <td>243896120</td>
          <td>60255410</td>
          <td>4316990</td>
          <td>3689590</td>
        </tr>
        <tr>
          <th>Triangles Speedup</th>
          <td>1</td>
          <td>4.047704928</td>
          <td>56.49679985</td>
          <td>66.10385436</td>
        </tr>
        <tr>
          <th>Cube Time</th>
          <td>451933440</td>
          <td>129664750</td>
          <td>10191510</td>
          <td>9694460</td>
        </tr>
        <tr>
          <th>Cube Speedup</th>
          <td>1</td>
          <td>3.485399386</td>
          <td>44.34410995</td>
          <td>46.61770124</td>
        </tr>
        <tr>
          <th>Stars and Hexagons Time</th>
          <td>916919410</td>
          <td>223390930</td>
          <td>11490170</td>
          <td>11520110</td>
        </tr>
        <tr>
          <th>Stars and Hexagons Speedup</th>
          <td>1</td>
          <td>4.104550753</td>
          <td>79.80033455</td>
          <td>79.59293878</td>
        </tr>
      </table>
      
    </div>
    <p>As can be seen above, simply removing unnecesary computations was enough to speed up overall rasterization by 3-4x. However, the most significant jump came when using the new algorithm, 
      which allowed for a speedup over baseline of two orders of magnitude, up to over 130x. In the future, these algorithms could be further sped up by using effective multiprocessing to simultaneously render triangles. 
    </p>

    

  <br />
  <hr />
  <br />
  <h2 align="middle">Task 2: Antialiasing by Supersampling</h2>

 
  <h3>Overview</h3>
  <p>

  </p>


  <div align="middle">
    <table style="width:100%">
      <tr align="center">
        <td>
            <img src="images/1ss.png" align="middle" width="400px" />
            <figcaption>$\text{Supersample Rate} = 1$</figcaption>
        </td>
        <td>
            <img src="images/4ss.png" align="middle" width="400px" />
            <figcaption>$\text{Supersample Rate} = 4$</figcaption>
            
        </td>
      </tr>
      <tr align="center">
        <!-- <td>
            <img src="images/9ss.png" align="middle" width="400px" />
            <figcaption>$\text{Supersample Rate} = 9$</figcaption>
        </td> -->
        <td>
            <img src="images/16ss.png" align="middle" width="400px" />
            <figcaption>$\text{Supersample Rate} = 16$</figcaption>
        </td>
      </tr>
    </table>

  </div>





    <p>
      We can see that Supersample rate 
    </p>


  <br />
  <hr />
  <br />

  <h2 align="middle">Task 3: Transforms</h2>
  
  <h3>Overview</h3>
  <p>
    [Write some stuff here about what we did to get the transforms, ig also maybe latex the matrices and explain them]
  </p>
  
  <blockquote><b>
    Create an updated version of svg/transforms/robot.svg with cubeman doing something more interesting, like waving or running. Feel free to change his colors or proportions to suit your creativity. Save your svg file as my_robot.svg in your docs/ directory and show a png screenshot of your rendered drawing in your write-up. Explain what you were trying to do with cubeman in words.
  </b></blockquote>

  <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
            <img src="images/robot_meditate.png" align="middle" width="700vw" />
            <figcaption> Here we have the cubeman crossing its knees while have its arms outstretched. The idea was to go for a more meditative pose with the cubeman while also incorporating a rainbow-like gradient across each major body part.</figcaption>
          </td>
        </tr>
      </table>
    </div>

  <br />
  <hr />
  <br />

  <h2 align="middle">Task 4: Barycentric coordinates</h2>
  </a>
  <h3>Overview</h3>
  <p>
    Barycentric coordinates are a way to represent points in a triangle as a linear combination of the vertices of that triangle. The sum of this linear combination must always equal to one or else the point will not within triangle. A clear example of this is when we consider a vertex itself. 
    In this scenario the coefficient corresponding to that vertex is 1 and all other coefficients are 0. If this were not the case, say that the coefficient for the vertex was greater than 1 then the point would actually be past the vertex and outside of the triangle. 
    With barycentric coordinates color sampling becomes very intuitive as we can then use the linear coefficients of these vertices for these points as the same coefficients for color sampling. Take the color triangle below as an example. Each vertex is one of red, green, or blue. The color of each point in the triangle is just a linear combination of red, green, and blue.
     As the point gets closer a given vertex we see it taking on more of that vertex's color. 
  </p>

  <div align="middle">
    <table style="width:100%">
      <tr align="center">
        <td>
            <img src="images/bary_tri.png" align="middle" width="400px" />
            <figcaption>Color Triangle</figcaption>
        </td>
        <td>
            <img src="images/test7.png" align="middle" width="400px" />
            <figcaption>Color Wheel</figcaption>
        </td>
      </tr>
    </table>
  </div>
  


  <br />
  <hr />
  <br />

  <h2 align="middle">Task 5: "Pixel sampling" for texture mapping</h2>
  </a>

    <blockquote><b>
      Check out the svg files in the svg/texmap/ directory. Use the pixel inspector to find a good example of where bilinear sampling clearly defeats nearest sampling. Show and compare four png screenshots using nearest sampling at 1 sample per pixel, nearest sampling at 16 samples per pixel, bilinear
    </b></blockquote>

    <p>
     
    </p>


    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
              <img src="images/nn_1ss.png" align="middle" width="400px" />
              <figcaption>$\text{Nearest Neighbor Supersample Rate 1}$</figcaption>
          </td>
          <td>
              <img src="images/bi_1ss.png" align="middle" width="400px" />
              <figcaption>$\text{Bilinear Supersample Rate 1}$</figcaption>
              
          </td>
        </tr>
        <tr align="center">
          <td>
              <img src="images/nn_16ss.png" align="middle" width="400px" />
              <figcaption>$\text{Nearest Neighbor Supersample Rate 16}$</figcaption>
          </td>
          <td>
              <img src="images/bi_16ss.png" align="middle" width="400px" />
              <figcaption>$\text{Bilinear Supersample Rate 16}$</figcaption>
          </td>
        </tr>
      </table>

    </div>
  <hr />



  <h2 align="middle">Task 6: "Level sampling" with mipmaps for texture mapping</h2>




   

</body>
</html>
