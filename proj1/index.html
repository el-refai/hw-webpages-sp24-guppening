<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <style>
    body {
      background-color: #404040;
      background-color: white;
      padding: 100px;
      width: 1000px;
      margin: auto;
      text-align: left;
      font-weight: 300;
      font-family: 'Open Sans', sans-serif;
      color: #121212;
      cursor: url(images/dwagon.png), default!important;
      cursor: url(images/dwagon.png), pointer!important;
    }
    h1, h2, h3, h4 {
      font-family: 'Source Sans Pro', sans-serif;
    }
    kbd {
      color: #121212;
    }
    blockquote {
      color: #888;
      border: 2px solid #333;
      padding: 10px;
      background-color: #ccc;
    }

    table.custom-tbl {
      border: 1px solid;
    }

    table.custom-tbl th {
      border: 1px solid;
      background-color: rgb(99, 209, 209);
    }

    table.custom-tbl td {
      border: 1px solid;
      background-color: #f1e686a8;
    }

    /* The alert message box */
    .alert {
      padding: 20px;
      background-color: #f44336; /* Red */
      color: white;
      margin-bottom: 15px;
    }

    /* The close button */
    .closebtn {
      margin-left: 15px;
      color: white;
      font-weight: bold;
      float: right;
      font-size: 22px;
      line-height: 20px;
      cursor: pointer;
      transition: 0.3s;
    }

    /* When moving the mouse over the close button */
    .closebtn:hover {
      color: black;
    }
  </style>

  <title>CS 184 Mesh Editor</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <!-- Not using below due to lacking bold fontfaces -->
  <!-- <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro|Source+Sans+Pro:400,700" rel="stylesheet"> -->
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono|Roboto+Slab|Roboto:300,400,500,700" rel="stylesheet" />

  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>  
</head>

<body
  style="padding-top: 50px;">

  <div align="middle">
    <img src="images/triangle_dragon_banner.webp" 
        align="middle" 
        width="1000vw" />
  </div>
  
  <h1 align="left">CS 184: Computer Graphics and Imaging, Spring 2024</h1>
  <h1 align="left">Homework 1: Rasterizer</h1>
  <h2 align="left">James Deloye, Karim El-Refai, cs-184-guppening</h2>

  <hr />
  <br />

  <div>
    <h2 align="left">Overview</h2>
    <p>
      We implemented everything from rasterizing single-color triangles to then antialiasing these triangles through supersampling. 
      We then got to take a little break designing the matrices in homogenous coordinates that describe translation, scaling, and rotation in 2D. 
      After that we worked on barycentric coordinates to interpolate the values of points along various shapes. 
      From there we got to deal with texture maps and rasterizing them in pixel-space with pixel sampling both using near-neighbors and bilinear sampling.
      Leading us to the last required task which was figuting out which mipmap level to sample from and adding in trilinear interpolation across mipmap levels.
      </p>
      <p>
      <br />
      However, this was not everything we did as we worked on all pieces of extra credit including increasing the speed of our rasterization by ~80x, jittered sampling, 
      more GUI features [James TALK ABOUT THIS] and lastly the implementation of anisotropic filtering according to the Nvidia specification.
      <br />
    </p>
    <p>
      We found this homework to be deeply instructive in demystifying the task of working with graphics. Neither of us had prior graphics experience but were able to 
      tackle all the tasks and achieve really cool results from our work on the extra credit. The most interesting things we dealt with in this project were how to 
      greatly speed up triangle rasterization and working on anisotropic filtering. 
    </p>
  </div>



  <hr />
  <br />
  <h2 align="middle">Task 1: Drawing Single-Color Triangles</h2>

  <h3>Overview</h3>
    <p>
      We rasterize 
      <br />
      We then construct the spring with <i>Structural</i>, <i>Shearing</i>, and <i>Bending</i> constraint types using <code>emplace_back</code>.
    </p>

    <blockquote><b>
      Take some screenshots of <i>scene/pinned2.json</i> from a viewing angle where you can clearly see the cloth wireframe 
      to show the structure of your point masses and springs. 
    </b></blockquote>

    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
            <img src="images/t1-zoomed-in_p2.png" align="middle" width="300vw" />
          </td>
          <td>
            <img src="images/t1-halfway_p2.png" align="middle" width="300vw" />
            <figcaption>Default settings ($\text{ks} = 5,000$)</figcaption>
          </td>
          <td>
            <img src="images/t1-zoomed-out_p2.png" align="middle" width="300vw" />
          </td>
        </tr>
      </table>
    </div>
    <p>
      Above we can see the wireframe of the cloth in <i>scene/pinned2.json</i> from a final zoomed-in viewing angle, 
      tilted but paused halfway during the simulation being played viewing angle, and a flat zoomed-out view from the beginning.
    </p>
  
    <blockquote><b>
      Show a png screenshot of basic/test4.svg with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.
    </b></blockquote>

    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
            <img src="images/task1.png" align="middle" width="700vw" />
            <figcaption>Here is the rasterizer working on basic/test4.svg. An interesting thing, as evidenced by the pixel inspector is how on the rightmost end of the red triangle it thins down to just a single pixel in thickness and actually oscillates between rasterizing any of the triangle and not. </figcaption>
          </td>
        </tr>
      </table>
    </div>


    <blockquote><b>
      Extra credit: Explain any special optimizations you did beyond simple bounding box triangle rasterization.
    </b></blockquote>    
    <p>
      Before doing any optimizing we designed a consistent testing methodology in order to compare between rasterization methods. For each method, we rasterized each of the 4 basic SVGs 10 times at 16x supersampling and took the average of all of them. This was done in order to show the greatest possible differences in the rendering methods. We used the std::chrono::steadyclock to measure the time that it took to render all the triangles for maximum consistency and then found the speedup against the naiive baseline bounding box method. We did the optimizations in stages as follows:
    </p>
    <ol>
      <li>
        We started with just the basic bounding box algorithm implemented in the most naiive way possible. We used this as our baseline that we compared other methods to. 
      </li>
      <li>
        We began by removing unnecessary computations, like repeated square roots for supersampling computations and the subtractions (like y1-y0) that were previously repeated for checking if each pixel was inside the triangle. Though this does result in more memory accesses, assuming good caching there will be less operations in total. These results are in the second column below. 
      </li>
      <li>
        From this point on, we apprached the rendering in a completely different method than was done previously. Instead of trying individual pixels to determine whether they were in the triangle, we started at the minimum y value in the triangle, found the pixels at which the triangle's edges intercepted that y value, then used the std::fill function to fill all the values between the two (sub)pixels. This was done until the entire triangle had been scanned. Technically, this was done in two phases, first where the triangle was widening and then when it was thinning, identifying the appropriate right and left edges using information about the orientation of the vertices. The loops were done with a while loop method, as this was simplest to implement intially. These results are in the third column below.
      </li>
      <li>
        In preparation for a final optimization using multithreading in order to parallelize the triangle filling loops, we switched the while loops to for loops. While it turned out that the overhead of spawning the threads was too high for the relatively small triangles, the for loops did slightly speed up the overall computation, likely due to assembly and branch prediction compiler optimizations. These results are in the fourth column below.
      </li>
    </ol>
    <head>
      <title>Performance Table</title>
      <style>
        table {
          width: 100%;
          border-collapse: collapse;
        }
        table, th, td {
          border: 1px solid black;
        }
        th, td {
          padding: 8px;
          text-align: center;
        }
        th {
          background-color: #f2f2f2;
        }
      </style>
      </head>
      <div align="middle">
      
      <table>
        <tr>
          <th>SVG File</th>
          <th>Slow (naive with bounding box)</th>
          <th>Fast (repetitive computations removed)</th>
          <th>Faster (new algorithm)</th>
          <th>Fastest (for loop)</th>
        </tr>
        <tr>
          <th>Dragon Time</th>
          <td>6464845470</td>
          <td>1461548720</td>
          <td>49709560</td>
          <td>46949350</td>
        </tr>
        <tr>
          <th>Dragon Speedup</th>
          <td>1</td>
          <td>4.423284275</td>
          <td>130.0523575</td>
          <td>137.6982955</td>
        </tr>
        <tr>
          <th>Triangles Time</th>
          <td>243896120</td>
          <td>60255410</td>
          <td>4316990</td>
          <td>3689590</td>
        </tr>
        <tr>
          <th>Triangles Speedup</th>
          <td>1</td>
          <td>4.047704928</td>
          <td>56.49679985</td>
          <td>66.10385436</td>
        </tr>
        <tr>
          <th>Cube Time</th>
          <td>451933440</td>
          <td>129664750</td>
          <td>10191510</td>
          <td>9694460</td>
        </tr>
        <tr>
          <th>Cube Speedup</th>
          <td>1</td>
          <td>3.485399386</td>
          <td>44.34410995</td>
          <td>46.61770124</td>
        </tr>
        <tr>
          <th>Stars and Hexagons Time</th>
          <td>916919410</td>
          <td>223390930</td>
          <td>11490170</td>
          <td>11520110</td>
        </tr>
        <tr>
          <th>Stars and Hexagons Speedup</th>
          <td>1</td>
          <td>4.104550753</td>
          <td>79.80033455</td>
          <td>79.59293878</td>
        </tr>
      </table>
      
    </div>
    <p>As can be seen above, simply removing unnecesary computations was enough to speed up overall rasterization by 3-4x. However, the most significant jump came when using the new algorithm, 
      which allowed for a speedup over baseline of two orders of magnitude, up to over 130x. In the future, these algorithms could be further sped up by using effective multiprocessing to simultaneously render triangles. 
    </p>

    

  <br />
  <hr />
  <br />
  <h2 align="middle">Task 2: Antialiasing by Supersampling</h2>

 
  <h3>Overview</h3>
  <p>
  </p>



    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
            <img src="images/t2-ks_5.png" align="middle" width="200vw" />
            <figcaption>$\text{ks} = 5$</figcaption>
          </td>
          <td>
            <img src="images/t2-ks_100.png" align="middle" width="200vw" />
            <figcaption>$\text{ks} = 100$</figcaption>
          </td>
          <td>
            <img src="images/t2-ks_1000.png" align="middle" width="200vw" />
            <figcaption>$\text{ks} = 1,000$</figcaption>
          </td>
          <td>
            <img src="images/t2-ks_5000.png" align="middle" width="200vw" />
            <figcaption>$\text{ks} = 5,000$</figcaption>
          </td>
          <td>
            <img src="images/t2-ks_10000.png" align="middle" width="200vw" />
            <figcaption>$\text{ks} = 10,000$</figcaption>
          </td>
        </tr>
      </table>
    </div>

    <p>
      Changing the spring constant <code>ks</code> to a very low value results in the fabric being very loose and not holding its initial shape. 
      Whether it was in the initial configuration or during the movement caused by the cloth dropping in the simulation, 
      the fabric was very stretch and loose.
      When we changed the spring constant <code>ks</code> to a very high value, the fabric was very tight 
      and while it still did not hold its initial shape perfectly, it was closer to doing so, 
      it was not as loose as when <code>ks</code> was very low: it was more stiff.

      This makes sense as the spring constant <code>ks</code> is the stiffness of the springs that connect the masses. 
      When <code>ks</code> is very low, the springs are very loose and the fabric is very stretchy. 
      When <code>ks</code> is very high, the springs are very tight and the fabric is very stiff 
      -- which means it will be very hard to stretch the fabric.
    </p>


    <blockquote><b>
      <small>
        What about for <code>density</code>?
      </small>
    </b></blockquote>

    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
            <img src="images/t2-density_5.png" align="middle" width="200vw" />
            <figcaption>$\text{density} = 5$</figcaption>
          </td>
          <td>
            <img src="images/t2-density_15.png" align="middle" width="200vw" />
            <figcaption>$\text{density} = 15$</figcaption>
          </td>
          <td>
            <img src="images/t2-density_50.png" align="middle" width="200vw" />
            <figcaption>$\text{density} = 50$</figcaption>
          </td>
          <td>
            <img src="images/t2-density_1000.png" align="middle" width="200vw" />
            <figcaption>$\text{density} = 1,000$</figcaption>
          </td>
          <td>
            <img src="images/t2-density_10000.png" align="middle" width="200vw" />
            <figcaption>$\text{density} = 10,000$</figcaption>
          </td>
        </tr>
      </table>
    </div>

    <p>
      The effect of density on cloth behavior is somewhat more complex. At first, it appears to be inverse to the effect
      of spring tension; as density decreases, the cloth descends more slowly from its starting position, and the top
      edge of the cloth deforms less under the cloth's own weight at rest, in a similar manner to increasing $k_s$. 
      However, the correlation with density on the level of deformation on the cloth's surface is non-linear; at low
      and high densities, the surface of the cloth is smooth; at medium densities, the surface shows more ripples. This 
      can be explained by the difference in how spring tension and density effect the dynamics of the point masses. The 
      former resists all changes in position, and thus with higher $k_s$ all forms of deformation are decreased. The
      latter directly corresponds to the mass of each point, which primarly affects deformation from the force of
      gravity. At low or high densities, either spring force or gravity are the dominant force, causing the surface to
      flatten out. At medium densities the forces are about equal which causes the point masses to be suspended and not
      flatten out.
    </p>


    <blockquote><b>
      <small>
        What about for <code>damping</code>?
      </small>
    </b></blockquote>

    <div class="alert">
      <span class="closebtn" onclick="this.parentElement.style.display='none';">&times;</span>
      <p>
        Note that the following four are <code>gif</code> files, so if you are viewing this as a <code>pdf</code> file, 
        you will not be able to see the animations. 
        <br />
        You can visit our site to see the animations (linked at the top of this page).
      </p>
    </div>

    <p>
      Damping acts as a weight on the velocity term of the Verlet integration, so a cloth that is more damped will move 
      more slowly, but the total forces at rest are unchanged. This result is demonstrated above. In addition, the two 
      cloths that were less damped oscillated like a tire swing before coming to rest -- the undamped cloth never came
      to rest at all, instead demonstrating a perpetual pendulumn motion.
    </p>


    <blockquote><b>
      <small>
      For each of the above, observe any noticeable differences in the cloth compared to the default parameters 
      and show us some screenshots of those interesting differences and describe when they occur.
      </small>
    </b></blockquote>
    
    <blockquote><b>
    Show us a screenshot of your shaded cloth from <i>scene/pinned4.json</i> in its final resting state! 
    If you choose to use different parameters than the default ones, please list them.
    </b></blockquote>

    <div align="middle">
      <img src="images/t2-pinned4.png" align="middle" width="100%" />
    </div>

    <blockquote><b>
      Extra Credit: Jitter supersampling
    </b></blockquote>

    <p>
      In addition to traditional grid supersampling, we also implemented jitter supersampling. This was easy to slot into our current implementation, and instead of taking the center of each subgrid cell, we took a uniform random spot within that grid cell and sampled that. Below are some comparisons between the two, supersampled at 4x for the triangles and 9x for the map.  
    </p>
    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
              <img src="images/uniform.png" align="middle" width="400px" />
              <figcaption>$\text{Grid Sampled Triangles}$</figcaption>
          </td>
          <td>
              <img src="images/jittered.png" align="middle" width="400px" />
              <figcaption>$\text{Jitter Sampled Triangles}$</figcaption>
              
          </td>
        </tr>
        <tr align="center">
          <td>
              <img src="images/gridmap.png" align="middle" width="400px" />
              <figcaption>$\text{Grid Sampled Map}$</figcaption>
          </td>
          <td>
              <img src="images/jittermap.png" align="middle" width="400px" />
              <figcaption>$\text{Jitter Sampled Map}$</figcaption>
          </td>
        </tr>
      </table>
    </div>

    <p>
      As can be seen, in areas where there is normally aliasing or discontinuities in the grid sampled rendering, with jitter sampling the edges blend more clearly. 
      This is due to the fact that the jittered sampling may sample parts of the background or interior of lines, leading to more blended looking pixel. 
      Though at higher sampling rates they tend to converge in quality, in the case that they are both at a lower rate jittered may outperform grid sampling due to its greater chance of blending around edges. 
    </p>
  <br />
  <hr />
  <br />

  <h2 align="middle">Task 3: Transforms</h2>
  
  <h3>Overview</h3>
  <p>
    [Write some stuff here about what we did to get the transforms, ig also maybe latex the matrices and explain them]
  </p>
  
  <blockquote><b>
    Create an updated version of svg/transforms/robot.svg with cubeman doing something more interesting, like waving or running. Feel free to change his colors or proportions to suit your creativity. Save your svg file as my_robot.svg in your docs/ directory and show a png screenshot of your rendered drawing in your write-up. Explain what you were trying to do with cubeman in words.
  </b></blockquote>

  <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
            <img src="images/robot_meditate.png" align="middle" width="700vw" />
            <figcaption> Here we have the cubeman crossing its knees while have its arms outstretched. The idea was to go for a more meditative pose with the cubeman while also incorporating a rainbow-like gradient across each major body part.</figcaption>
          </td>
        </tr>
      </table>
    </div>


    <blockquote><b>
      <small>Describe the differences in the results.</small>
    </b></blockquote>

    <p>
      The higher the spring constant, the less the shape of the cloth conforms around the sphere after coming to rest
      around it. As the parts of the cloth touching the top of the sphere come to rest first, they exert corrective
      spring forces on the rest of the cloth, pulling them upwards. If these forces are weak, the rest of the cloth
      continues to descend and bring more points tangent to the sphere. If the forces are strong, they bring these parts
      of the cloth to rest before more "wrapping" is possible, causing sections of cloth to flare outward from the 
      sphere.
    </p>


    <blockquote><b>
      Show us a screenshot of your shaded cloth lying peacefully at rest on the plane. 
      If you haven't by now, feel free to express your colorful creativity with the cloth! 
      (You will need to complete the shaders portion first to show custom colors.)
    </b></blockquote>

    <div align="middle">
      <img src="images/t3-plane_shaded.png" align="middle" width="100%" />
    </div>



  <br />
  <hr />
  <br />

  <h2 align="middle">Task 4: Barycentric coordinates</h2>
  </a>
  <h3>Overview</h3>
  <p>
    This doesn't account for all possible collisions; most critically, it doesn't handle when the cloth collides with
    itself! You can see this when running <code>./clothsim -f ../scene/selfCollision.json</code> with unfortunate
    results.
  </p>

  <div align="middle">
    <img src="images/t4-self-collapse.png" align="middle" width="100%" />
  </div>
  <p>
    The solution to this problem is an intuitive one; check for pairs of point masses that are too close to each other,
    and apply a position correction that simulates the repulsive force between the two masses. The final change in
    position of each point mass is the average of their correction vectors.
  </p>
  <br />
  <p>
    Checking every pair of points requires $O(n^2)$ time, which is not suitable for our large number of points. Instead,
    we partition the 3D space into a set of boxes, and hash each point to a table based on which box contains them.
    Since a point mass can only collide with the masses in the same box, this causes collision checking to speed up
    considerably.
  </p>
  <br />



    <blockquote><b>
      Show us at least 3 screenshots that document how your cloth falls and folds on itself, 
      starting with an early, initial self-collision 
      and ending with the cloth at a more restful state (even if it is still slightly bouncy on the ground).
    </b></blockquote>
    
    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
            <img src="images/t4-collision-1.png" align="middle" width="150vw" />
            <figcaption>Self collision 1</figcaption>
          </td>
          <td>
            <img src="images/t4-collision-1_5.png" align="middle" width="150vw" />
            <figcaption>Self collision 2</figcaption>
          </td>
          <td>
            <img src="images/t4-collision-2.png" align="middle" width="150vw" />
            <figcaption>Self collision 3</figcaption>
          </td>
          <td>
            <img src="images/t4-collision-2_5.png" align="middle" width="150vw" />
            <figcaption>Self collision 4</figcaption>
          </td>
          <td>
            <img src="images/t4-collision-3.png" align="middle" width="150vw" />
            <figcaption>Self collision 5</figcaption>
          </td>
          <td>
            <img src="images/t4-collision-3_5.png" align="middle" width="150vw" />
            <figcaption>Self collision 6</figcaption>
          </td>
        </tr>
      </table>
    </div>
    
    <blockquote><b>
      Vary the <code>density</code> as well as <code>ks</code> 
      
      and describe with words and screenshots how they affect the behavior of the cloth as it falls on itself.
    </b></blockquote>

    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
              <img src="images/t4-density-1.png" align="middle" width="400px" />
              <figcaption>$\text{density} = 1$</figcaption>
              
          </td>
          <td>
              <img src="images/t4-density-50.png" align="middle" width="400px" />
              <figcaption>$\text{density} = 50$</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
              <img src="images/t4-ks-1.png" align="middle" width="400px" />
              <figcaption>$\text{ks} = 2,500$</figcaption>
          </td>
          <td>
              <img src="images/t4-ks-2.png" align="middle" width="400px" />
              <figcaption>$\text{ks} = 7,500$</figcaption>
          </td>
        </tr>
      </table>
    </div>

    <p>
      Above we can see that higher densities and lower spring constants cause the cloth to fold in on itself more 
      erratically. This is because the cloth is more likely to collide with itself in small folds when it is more 
      dense, and the cloth is more likely to be pulled apart when the spring constants are lower.
    </p>


  <br />
  <hr />
  <br />

  <h2 align="middle">Task 5: "Pixel sampling" for texture mapping</h2>
  </a>

    <blockquote><b>
    Explain in your own words what is a shader program and how vertex and fragment shaders work together to create lighting and material effects.
    </b></blockquote>

    <p>
      A shader program is user-defined code that a graphics processor uses during its rendering pipeline. In this
      pipeline, vertex shaders operate before fragment shaders; they are responsible for the geometry of individual
      vertices in the model being rendered. For each vertex, the shader transforms the vertex position as necessary
      (converting to post-projection space or, in the case of displacement mapping, offsetting the position according
      to some vertex property), as well as generating information on that vertex necessary to per-vertex lighting, such
      as the vertex normal and texture coordinate <em>uv</em>. The fragment shader operates after the vertex shader has
      completed, using "fragments" of the rasterized model. Its job is to determine the color of this rastered fragment,
      using the vertex information produced by the vertex shader as well as the specified shading method (Blinn-Phong, 
      texture-mapped, etc). Each fragment shader typically corresponds to a unique shading method.
    </p>


    <blockquote><b>
    Explain the Blinn-Phong shading model in your own words. 
    Show a screenshot of your Blinn-Phong shader outputting only the ambient component, a screen shot only outputting the diffuse component, a screen shot only outputting the specular component, and one using the entire Blinn-Phong model.
    </b></blockquote>

    <p>
      Blinn-Phong shading is a per-vertex shading model that takes the surface normal at the vertex $\mathbf{n}$, as
      as the ray from the vertex to the point light source $\mathbf{l}$, as well as the light intensity $\mathbf{I}$
      and distance to the light source $r = ||l||$, and computes the intensity of the light arriving at that vertex:
      $$
        \mathbf{L} = \underbrace{k_a\mathbf{I}_a}_{\text{Ambient component}} + \underbrace{\mathbf{k}_d (\mathbf{I} / r^2) \max(0, \mathbf{n} \cdot \mathbf{l})}_{\text{Diffuse component}} + \underbrace{k_s (\mathbf{I} / r^2) \max(0, \mathbf{n} \cdot \mathbf{h})^p}_{\text{Specular component}}
      $$
      Let us examine the three terms individually. The ambient component approximates ambient light, or the light that
      that would hypothetically arrive after more than one bounce (since our scene comprises only the sphere and cloth,
      this is uncommon and can't really be modeled). We use the crude but effective method of setting ambient lighting
      to a constant:
      $$
        k_a = 0.1, \mathbf{I}_a = \mathbb{1}
      $$ 
      The diffuse component represents the diffuse (uniform over a hemisphere) reflection of light by the sphere and
      cloth. It is affected by the distance to the light as well as the angle of the surface relative to the direction
      of light, as determined by Lambert's cosine law. Since this comprises a vast majority of the total reflectance of
      the scene in the Blinn-Phong model, we weight this term by 100% of the light emitted (in other words, $\mathbf{k}_d$ equals the RGB intensity of the light source).
    </p>
    <p>
      Finally, there is specular lighting. Like ambient lighting, this represents a small minority of the total lighting

      in the render. It represents the light that is reflected off the scene in a mirror-like fashion. For us to see this specular reflection at a vertex, the outgoing vector $v$ from that vertex to the camera must be the mirror
      reflection of the incident vector $l$ from the light source to that vertex. In mathematical terms, the bisecting
      vector
      $$
      h = \frac{v + l}{||v + l||}
      $$
      must be as close to the normal as possible. Thus the intensity of the specular component is dependent on $n \cdot 
      h$. Since we want the reflectance to taper off quickly for less than perfect specular reflectance ($n \cdot h < 
      1$), we will raise this term to a large power, in our case $p = 100$. We set $k_s = 0.5$.
    </p>

    <p>
      <b>Note:</b> unless otherwise stated, all renders are performed with the settings <code>-o 128 -a 128</code>.
    </p>

    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
              <img src="images/t5-blinn_phong_ambient.png" align="middle" width="400px" />
              <figcaption>Ambient component only</figcaption>
              
          </td>
          <td>
              <img src="images/t5-blinn_phong_diffuse.png" align="middle" width="400px" />
              <figcaption>Diffuse component only</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
              <img src="images/t5-blinn_phong_specular.png" align="middle" width="400px" />
              <figcaption>Specular component only</figcaption>
          </td>
          <td>
              <img src="images/t5-blinn_phong_all.png" align="middle" width="400px" />
              <figcaption>Complete Blinn-Phong model</figcaption>
          </td>
        </tr>
      </table>
    </div>

      
    <blockquote><b>
    Show a screenshot of your texture mapping shader using your own custom texture by modifying the textures in <code>/textures/</code>.
    </b></blockquote>

    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
            <img src="images/t5-custom_texture.png" align="middle" width="400vw" />
            <figcaption>The custom texture image</figcaption>
          </td>
          <td>
            <img src="images/t5-custom_cloth.png" align="middle" width="400vw" />
            <figcaption>The custom texture mapped to the sphere and cloth</figcaption>
          </td>
        </tr>
      </table>
    </div>


    <blockquote><b>
    Show a screenshot of bump mapping on the cloth and on the sphere. 
    Show a screenshot of displacement mapping on the sphere. 
    Use the same texture for both renders. 
    You can either provide your own texture or use one of the ones in the textures directory, 
    BUT choose one that's not the default <code>texture_2.png</code>. 
    Compare the two approaches and resulting renders in your own words. 
    Compare how your the two shaders react to the sphere by changing the sphere mesh's coarseness by using <code>-o 16 -a 16</code> and then <code>-o 128 -a 128</code>.
    </b></blockquote>

    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
            <img src="images/t5-bump_cloth.png" align="middle" width="400vw" />
            <figcaption>Bump Mapping on the Cloth</figcaption>
          </td>
          <td>
            <img src="images/t5-bump_sphere.png" align="middle" width="400vw" />
            <figcaption>Bump Mapping on the Sphere</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
            <img src="images/t5-displacement_sphere_fine.png" align="middle" width="400vw" />
            <figcaption>Displacement Mapping on the Sphere</figcaption>
          </td>
        </tr>
      </table>
    </div>

    <p>
      While both bump mapping and displacement mapping display the texture on the cloth's surface, in the case of the
      former, the geometry of the cloth is unmodified, giving the texture a "flat" look. The latter, by comparison,
      modifies the vertices of the cloth according to the texture height, introducing a further degree of realism; this
      can be seen in the rough profile of the render.
    </p>
    <p>
      The above images were rendered with a horizontal and vertical vertex resolution of 128. When we decrease this
      resolution to 16 x 16, notice the increase in smoothness of displacement mapping due to there being fewer
      vertices to transform:
    </p>

    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
            <img src="images/t5-displacement_sphere_fine.png" align="middle" width="400vw" />
            <figcaption>Displacement Mapping on the Sphere (Smooth mesh)</figcaption>
          </td>
          <td>
            <img src="images/t5-displacement_sphere_coarse.png" align="middle" width="400vw" />
            <figcaption>Displacement Mapping on the Sphere (Coarse mesh)</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
            <img src="images/t5-displacement_cloth_fine.png" align="middle" width="400vw" />
            <figcaption>Displacement Mapping on the Cloth (Smooth mesh)</figcaption>
          </td>
          <td>
            <img src="images/t5-displacement_cloth_coarse.png" align="middle" width="400vw" />
            <figcaption>Displacement Mapping on the Cloth (Coarse mesh)</figcaption>
          </td>
        </tr>
      </table>
    </div>

    <blockquote><b>
    Show a screenshot of your mirror shader on the cloth and on the sphere.
    </b></blockquote>

    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
            <img src="images/t5-mirror_cloth.png" align="middle" width="400vw" />
            <figcaption>Mirror Shader on the Cloth</figcaption>
          </td>
          <td>
            <img src="images/t5-mirror_sphere.png" align="middle" width="400vw" />
            <figcaption>Mirror Shader on the Sphere</figcaption>
          </td>
        </tr>
      </table>
    </div>


    <blockquote><b>
    Explain what you did in your custom shader, if you made one.
    </b></blockquote>

    <p>
      We synthesized all of the above shading methods into a single custom shader, combining Blinn-Phong shading,
      displacement mapping, and mirror shading (Bump mapping and diffuse shading are subsets of some of these
      techniques, and texture mapping was incompatible with mirror reflection). Notice the visble texture and roughness
      of profile compared to the original mirror render, as well as the brighter colors from Blinn-Phong shading:
    </p>
    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
            <img src="images/ec-sphere_mirror.png" align="middle" width="400vw" />
            <figcaption>Sphere, mirrored</figcaption>
          </td>
          <td>
            <img src="images/ec-sphere_custom.png" align="middle" width="400vw" />
            <figcaption>Sphere, custom shader</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
            <img src="images/ec-cloth_mirror.png" align="middle" width="400vw" />
            <figcaption>Cloth, mirrored</figcaption>
          </td>
          <td>
            <img src="images/ec-cloth_custom.png" align="middle" width="400vw" />
            <figcaption>Cloth, custom shader</figcaption>
          </td>
        </tr>
      </table>
    </div>

    <p>

      
  <hr />



  <h2 align="middle">Task 6: "Level sampling" with mipmaps for texture mapping</h2>

  <h2 align="middle">Contributions</h2>
  <p>
    We both contributed at least some work to each part of this project. Rahul took the lead on parts 3 and 4, as well
    as exhaustively formatting our writeup webpage. Calvin implemented the majority of parts 2 and 5, in addition to
    extra credit features. Contributions to task 1, as well as the content of the writeup, were about equal.
  </p>



   

</body>
</html>
