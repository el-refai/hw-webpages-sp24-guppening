<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <style>
    body {
      background-color: #404040;
      background-color: white;
      padding: 100px;
      width: 1000px;
      margin: auto;
      text-align: left;
      font-weight: 300;
      font-family: 'Open Sans', sans-serif;
      color: #121212;
      cursor: url(images/cursor/teacwup.png), default!important;
      cursor: url(images/cursor/teacwup.png), pointer!important;
    }
    h1, h2, h3, h4 {
      font-family: 'Source Sans Pro', sans-serif;
    }
    kbd {
      color: #121212;
    }
    blockquote {
      color: #888;
      border: 2px solid #333;
      padding: 10px;
      background-color: #ccc;
    }

    table.custom-tbl {
      border: 1px solid;
    }

    table.custom-tbl th {
      border: 1px solid;
      background-color: rgb(99, 209, 209);
    }

    table.custom-tbl td {
      border: 1px solid;
      background-color: #f1e686a8;
    }

    /* The alert message box */
    .alert {
      padding: 20px;
      background-color: #f44336; /* Red */
      color: white;
      margin-bottom: 15px;
    }

    /* The close button */
    .closebtn {
      margin-left: 15px;
      color: white;
      font-weight: bold;
      float: right;
      font-size: 22px;
      line-height: 20px;
      cursor: pointer;
      transition: 0.3s;
    }

    /* When moving the mouse over the close button */
    .closebtn:hover {
      color: black;
    }
  </style>

  <title>CS 184 Homework 2</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <!-- Not using below due to lacking bold fontfaces -->
  <!-- <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro|Source+Sans+Pro:400,700" rel="stylesheet"> -->
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono|Roboto+Slab|Roboto:300,400,500,700" rel="stylesheet" />

  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>  
</head>
	<body
		style="padding-top: 50px;">
		<div align="middle">
		  <img src="images/beetlemesh.png" 
			  align="middle" 
			  width="500vw" />
		</div>
		
		<h1 align="left">CS 184: Computer Graphics and Imaging, Spring 2024</h1>
		<h1 align="left">Homework 2: Bezier Curves and Triangle Meshes</h1>
		<h2 align="left">James Deloye, Karim El-Refai, cs-184-call-it-the-guppening</h2>

		<hr />
		<br />
	  
		<div>
		  <h2 align="left">Overview</h2>
		  <p>
			Shitter intro
		  </p>
		</div>
	  
	  
		<hr />
		<br />
		<h2 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h2>
	  
		<h3>Overview</h3>
		  <p>
			<ul>
				Shid
		  </ul>
		  </p>
	  
		  
		  <blockquote><b>
			Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press E to step through. Toggle C to show the completed Bezier curve as well.
		  </b></blockquote>


		  <blockquote><b>
			Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter t via mouse scrolling.
		  </b></blockquote>

	  
		  <div align="middle">
			<table style="width:100%">
			  <tr align="center">
				<td>
				  <img src="images/task1.png" align="middle" width="700vw" />
				  <figcaption>Here is the rasterizer working on basic/test4.svg. An interesting thing, as evidenced by the pixel inspector, is how on the rightmost end of the red triangle it thins down to just a single pixel in thickness and actually oscillates between rasterizing parts of the triangle and not. </figcaption>
				</td>
			  </tr>
			</table>
		  </div>
	
		  
	  
		<br />
		<hr />
		<br />
		<h2 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h2>
	  
	   
		<h3>Overview</h3>
		<p>
			Shid
		</p>
	  
		<blockquote><b>
			Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.
		  </b></blockquote>
	  
		<div align="middle">
		  <table style="width:100%">
			<tr align="center">
			  <td>
				  <img src="images/1ss.png" align="middle" width="400px" />
				  <figcaption>$\text{Supersample Rate} = 1$</figcaption>
			  </td>
			  <td>
				  <img src="images/4ss.png" align="middle" width="400px" />
				  <figcaption>$\text{Supersample Rate} = 4$</figcaption>
				  
			  </td>
			</tr>
			<tr align="center">
			  <!-- <td>
				  <img src="images/9ss.png" align="middle" width="400px" />
				  <figcaption>$\text{Supersample Rate} = 9$</figcaption>
			  </td> -->
			  <td>
				  <img src="images/16ss.png" align="middle" width="400px" />
				  <figcaption>$\text{Supersample Rate} = 16$</figcaption>
			  </td>
			</tr>
		  </table>
	  
		</div>
	
		<br />
		<hr />
		<br />
	  
		<h2 align="middle">Part 3: Area-Weighted Vertex Normals</h2>
		
		<h3>Overview</h3>
		<p>
			Shid
		</p>
		
		<blockquote><b>
			Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use Q to toggle default flat shading and Phong shading.
		</b></blockquote>
	  
		<div align="middle">
			<table style="width:100%">
			  <tr align="center">
				<td>
				  <img src="images/robot_meditate.png" align="middle" width="700vw" />
				  <figcaption> Here we have the cubeman crossing its knees while have its arms outstretched. The idea was to go for a more meditative pose with the cubeman while also incorporating a rainbow-like gradient across each major body part.</figcaption>
				</td>
			  </tr>
			</table>
		  </div>
	  
		<br />
		<hr />
		<br />
	  
		<h2 align="middle">Part 4: Edge Flips</h2>
		</a>
		<h3>Overview</h3>
		<p>
		  <ul>
			To implement edge flips in our mesh, we started by making drawings like the ones suggested in the spec, such that we have a ground truth to debug against. When the function is called, we first check that the edge is not on a boundary adn then started by getting pointers (or rather iters) to each halfedge, edge, face, and vertex that surrounded the edge being flipped. From there, all we had to do was look to our drawings and fill the new corresponding pointers for halfedges, faces, edges, and vertices, while ensuring that the original edge has been flipped to the correct orientation. Outside of our use of the drawing method, we didn't find that we needed any special methods to complete this task.
		</ul>
	</p>
	<blockquote><b>
		Show screenshots of a mesh before and after some edge flips.
	  </b></blockquote>											
		<div align="middle">
		  <table style="width:100%">
			<tr align="center">
			  <td>
				  <img src="images/before.png" align="middle" width="400px" />
				  <figcaption>Teapot Mesh Before Flips</figcaption>
			  </td>
			  <td>
				  <img src="images/flipped.png" align="middle" width="400px" />
				  <figcaption>Teapot Mesh After Flips</figcaption>
			  </td>
			</tr>
		  </table>
		</div>

		<p>
			Since our implementation worked on the first try, we luckily didn't end up needing to do any debugging!
		</p>
		
	  
	  
		<br />
		<hr />
		<br />
	  
		<h2 align="middle">Part 5: Edge Splits</h2>
		</a>
	  
		<h3>Overview</h3>
		<p>
		  <ul>
			Like the edge flips, we again by making drawings like the ones suggested in the spec, this time noting down the new halfedges, edges, faces, and vertices that would need to be made. We then went about implementing the function similarly, by first getting pointers to the appropriate elements and then creating the new elements that would be needed to split the edge. From there we calculated the proper edge midpoint to get the position of the new vertex and finally set all the applicable pointers for halfedges, edges, faces, and vertices. As a debugging trick, we were sure to use the check_for functions which allowed us to check and make sure that each element was pointing to and pointed to by the correct elements. 
			</ul>
		</p>
		  <blockquote><b>
			Show screenshots of a mesh before and after some edge splits.
		</b></blockquote>
	  
		<div align="middle">
			<table style="width:100%">
			  <tr align="center">
				<td>
					<img src="images/before.png" align="middle" width="400px" />
					<figcaption>$\text{Before Splits}$</figcaption>
				</td>
				<td>
					<img src="images/splitmesh.png" align="middle" width="400px" />
					<figcaption>$\text{After Splits}$</figcaption>
					
				</td>
			  </tr>
			</table>
		  </div>

		<blockquote><b>
			Show screenshots of a mesh before and after a combination of both edge splits and edge flips.
		</b></blockquote>

		<div align="middle">
			<table style="width:100%">
			  <tr align="center">
				<td>
					<img src="images/splitmesh.png" align="middle" width="400px" />
					<figcaption>$\text{After Splits Before Flips}$</figcaption>
				</td>
				<td>
					<img src="images/flipsplit.png" align="middle" width="400px" />
					<figcaption>$\text{After Flips}$</figcaption>
					
				</td>
			  </tr>
			</table>
		  </div>

		  <p>
			Unlike the previous task, we (unfortunately) had an eventful debugging journey. When we first tried to run the function, we saw that nothing rendered at all, which suggested to us that there was some inconsistency with our updated pointers. We checked all the updates against our drawings again and again, but were still unable to noice any issues. We at last resorted to using the check_for function, and finally noticed that one of our half edges had two twins, and we knew we had found our culprit. For a single half edge, we had accidentally switched around the next and twin half edges, resulting in our mesh being unable to render. After this though, everything went smoothly. 
		  </p>

		<blockquote><b>
			If you have implemented support for boundary edges, show screenshots of your implementation properly handling split operations on boundary edges.
		</b></blockquote>

		  <p>
		   To support boundary edges, we again made drawings, this time with just a single triangle on a boundary. The tricky part for this extra credit was figuring out the correct method for splitting the halfedge on the boundary, and we settled on making the new halfedge the next edge of the original boundary edge, making sure to set its next and face pointers to be the same as those of the original existing edge. From there everything worked as expected, and we were able to split boundary edges without any need for debugging. 
		  </p>
	  
		  <div align="middle">
			<table style="width:100%">
			  <tr align="center">
				<td>
					<img src="images/.png" align="middle" width="400px" />
					<figcaption>$\text{Boundary Before Split}$</figcaption>
				</td>
				<td>
					<img src="images/.png" align="middle" width="400px" />
					<figcaption>$\text{Boundary After Split}$</figcaption>
					
				</td>
			  </tr>
			</table>
		</div>

		<hr />
	  
	  
	  
		<h2 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h2>
		<h3>Overview</h3>
		<p>
			<ul>
			To perform loop upsampling, we followed the rough outline provided by the spec. We started by iterating through all the vertices in the mesh and for each one set its isNew value to false and then computed the new position for the vertex via the equations provided in lecture. Next we did something similar for all the edges in the mesh, setting their isNew value to false and calculating the position of the new vertex that will be in the middle of the edge. Next we iterated through all the edges again, this time splitting each edge which had isNew = False and setting the newPosition value of the outputted vertex to be the newposition value of the edge that it was split from. We also modified our splitting function and edge class in two ways. First, we set all the new edges made from the splitting to have the isNew attribute be true. Second, we added an isValid attribute, which basically indiciated whether the edge was valid to be flipped afterwards. We only made this true in the splitting function for edges that spanned across the faces (instead of the new edge edge that went along the old edge being split). In the penultimate loop, we iterate through every single edge, and for each that is an isValid attribute set to true and is connected to one new vertex and one old vertex, we flip the edge. Lastly, we iterate through all the vertices, and set their position to their newPosition value, which was computed earlier. The isValid attribute proved to be critical to ensuring that we didn't flip unnecesary edges, as before we did this we had bugs with our meshes having incorrectly flipped edges. 
		</ul>
		</p>
	  
		<div align="middle">
		  <table style="width:100%">
			<tr align="center">
			  <td>
				  <img src="images/cubel0.png" align="middle" width="300px" />
				  <figcaption>$\text{Cube With No Subdivision}$</figcaption>
			  </td>
			  <td>
				  <img src="images/cubel1.png" align="middle" width="300px" />
				  <figcaption>$\text{Cube With Level 1 Loop Subdivision}$</figcaption>
			  </td>
			  <td>
				<img src="images/cubel2.png" align="middle" width="300px" />
				<figcaption>$\text{Cube With Level 2 Loop Subdivision}$</figcaption>
			</td>
			</tr>
			<tr align="center">
				<td>
					<img src="images/cubel3.png" align="middle" width="300px" />
					<figcaption>$\text{Cube With Level 3 Loop Subdivision}$</figcaption>
				</td>
				<td>
					<img src="images/cubel4.png" align="middle" width="300px" />
					<figcaption>$\text{Cube With Level 4 Loop Subdivision}$</figcaption>
				</td>
			</tr>
		  </table>
	  
		</div>

	  
		<blockquote><b>
			Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?
		</b></blockquote>

		<p>
			Looking at the screenshots above, we can see that sharp corners tend to add a bump to the mesh that does not get well smoothed out, even after multiple subdivisions. By pre-splittng some edges, this essentially provides more polygons around these sharp areas, allowing for a greater degree of smoothing when the Loop subdivision is performed. Below, the edges around the upper right corner of the cube have been pre-split. Upon subdivision, you can see that compared to the lower left corner, the cube is a lot more smooth and rounded. Thus we can see that when we are dealing with sharp differences in the behavior of a mesh, by increasing the number of triangles in the area subdivision will be more effective and smoothing sharp regions. 
		</p>

		<div align="middle">
			<table style="width:100%">
			  <tr align="center">
				<td>
					<img src="images/precubel0.png" align="middle" width="500px" />
					<figcaption>$\text{Preprocessed Cube With No Subdivision}$</figcaption>
				</td>
				<td>
					<img src="images/precubel1.png" align="middle" width="500px" />
					<figcaption>$\text{Preprocessed Cube With Level 1 Loop Subdivision}$</figcaption>
				</td>
			  </tr>
			  <tr align="center">
				  <td>
					  <img src="images/precubel2.png" align="middle" width="500px" />
					  <figcaption>$\text{Preprocessed Cube With Level 2 Loop Subdivision}$</figcaption>
				  </td>
				  <td>
					  <img src="images/precubel3.png" align="middle" width="500px" />
					  <figcaption>$\text{Preprocessed Cube With Level 3 Loop Subdivision}$</figcaption>
				  </td>
			  </tr>
			</table>
		
		  </div>

		<blockquote><b>
			Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects
		</b></blockquote>

		<p>
			In the original cube, the sides of the cubes are asymmetric in terms of the triangle positioning. Two corners are connected by edges and two are not. This leads to the asymmetry and almost pear-shaped (no pun intended) look of the cube after subdivision. By splitting this central edge on each side, now there is an edge going to each corner on each side of the cube, making the cube fully symmetric. Once we've subdivided with this change, the cube remains symmetric afterwards and retains a more uniform smoothed shape. 
		</p>

		<div align="middle">
			<table style="width:100%">
			  <tr align="center">
				<td>
					<img src="images/symmetriccube.png" align="middle" width="500px" />
					<figcaption>$\text{Symmetric Cube With No Subdivision}$</figcaption>
				</td>
				<td>
					<img src="images/symmetriccubeL2.png" align="middle" width="500px" />
					<figcaption>$\text{Symmetric Cube With Level 2 Loop Subdivision}$</figcaption>
				</td>
			  </tr>
			  <tr align="center">
				  <td>
					  <img src="images/symmetriccubeL4.png" align="middle" width="500px" />
					  <figcaption>$\text{Symmetric Cube With Level 4 Loop Subdivision}$</figcaption>
				  </td>
			  </tr>
			</table>
		
		  </div>

		<blockquote><b>
			If you have implemented any extra credit extensions, explain what you did and document how they work with screenshots.
		</b></blockquote>

		<h3>Supporting Boundary Edge Subdivision</h3>
		<p>
			<ul>
				To support boundary edge subdivision, we needed to find new equations for calculating the new positions of boundary vertices and the positions of vertices in split boundary edges. Since we want to keep boundaries very close to what they were before, according to the original Loop subdivision algorithm we do a weighted average of only the other vertices along the edge. For existing vertices, this was $\frac 34$ of the original vertex's position along with $\frac 14$ of the two vertices on either side of it. For vertices that came from boundary edge splits, we simply took the average of the two vertices that were on either side of the original edge. Since we had already implemented boundary edge splits, this was all we had to do, and the rest was compatible with our original Loop subdivision implementation.
			</ul>
		</p>

		<div align="middle">
		  <table style="width:100%">
			<tr align="center">
			  <td>
				  <img src="images/nearest.png" align="middle" width="400px" />
				  <figcaption>$\text{Boundary Mesh Level 0}$</figcaption>
			  </td>
			  <td>
				  <img src="images/bilinear.png" align="middle" width="400px" />
				  <figcaption>$\text{Boundary Mesh With Level 1 Loop Subdivision}$</figcaption>
				  
			  </td>
			</tr>
			<tr align="center">
			  <td>
				  <img src="images/trilinear.png" align="middle" width="400px" />
				  <figcaption>$\text{Boundary Mesh With Level 2 Loop Subdivision}$</figcaption>
			  </td>
			  <td>
				  <img src="images/aniso.png" align="middle" width="400px" />
				  <figcaption>$\text{Boundary Mesh With Level 3 Loop Subdivision}$</figcaption>
			  </td>
			</tr>
		  </table>
		</div>

		<h3>Adding $\sqrt 3$ Subdivision</h3>
		<p>
			In addition to Loop subdivision, we also implemented $\sqrt 3$ subdivision. Instead of splitting edges, this method splits faces into three separate faces, adding an edge between a central vertex that is the average of the original vertex positions and each of the original vertices surrounding the face. Then the original edges get flipped to maintain a regular structure. And the vertex positions are updated. To do this, we just had to implement a face split function, and then created a subdivision function very similar to that of Loop subdivision, replacing the vertex recomputation function with the one from the original root 3 subdivision paper and replacing edge splits with face splits. From the images below, one can see that this method is a lot better at smoothing out sharp edges, and by the time level 4 subdivision is reached, the mesh is almost spherical, save for a few extrordinary vertices.
		</p>

		<div align="middle">
			<table style="width:100%">
			  <tr align="center">
				<td>
					<img src="images/cubel0.png" align="middle" width="300px" />
					<figcaption>$\text{Cube With No Subdivision}$</figcaption>
				</td>
				<td>
					<img src="images/rootl1.png" align="middle" width="300px" />
					<figcaption>$\text{Cube With Level 1 $\sqrt 3$ Subdivision}$</figcaption>
				</td>
				<td>
				  <img src="images/rootl2.png" align="middle" width="300px" />
				  <figcaption>$\text{Cube With Level 2 $\sqrt 3$ Subdivision}$</figcaption>
			  </td>
			  </tr>
			  <tr align="center">
				  <td>
					  <img src="images/rootl3.png" align="middle" width="300px" />
					  <figcaption>$\text{Cube With Level 3 $\sqrt 3$ Subdivision}$</figcaption>
				  </td>
				  <td>
					  <img src="images/rootl4.png" align="middle" width="300px" />
					  <figcaption>$\text{Cube With Level 4 $\sqrt 3$ Subdivision}$</figcaption>
				  </td>
			  </tr>
			</table>
		  </div>
	  </body>
	  </html>
	  
